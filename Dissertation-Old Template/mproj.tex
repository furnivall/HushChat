\documentclass{mproj}
\usepackage{graphicx}

\usepackage{url}
\usepackage{fancyvrb}
\usepackage[final]{pdfpages}
\usepackage{times}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{An end-to-end encrypted mobile chat application with accessibility features}
\author{Daniel Furnivall}
\date{October 15th, 2021}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{abstract}
%abstract goes here
%\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%educationalconsent

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section*{Acknowledgements}
%acknowledgements go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}

\section{Aim}
To develop a synchronous/asynchronous peer-to-peer instant messaging Android application that includes a central server, end-to-end encryption and various accessibility features such as text-to-speech functionality.
\section{Objectives}
\subsection{Ability to send messages to other users}
This is the basic requirement of the service, and should be prioritised above all else. Messages should be stored on the server until they are claimed by the relevant client (i.e. until they log in). Once claimed, they will be removed from the server. If the user is already logged in, the message can be sent directly to the user and deleted from the server immediately.
\subsection{End-to-end Encryption (E2EE)}
There are several algorithms that we can use to implement E2EE (e.g. Diffie-Hellman key exchange \cite{diffie1979privacy}, PGP \cite{garfinkel1995pgp} or RSA  \cite{milanov2009rsa}), each with their own strengths and weaknesses for this type of application. The algorithm implemented will depend on the outcome of the literature review.
\subsection{Text-to-Speech (TTS) Functionality}
TTS functionality will be developed using an online API. There are several API options to choose from, including several which are artificially generated by neural networks such as Azure TTS\cite{tan2021survey} and Google WaveNet\cite{oord2016wavenet}.
\subsection{Client-side message history}
Unencrypted message history will be stored on the client side in an SQLite database. Message storage allows for lots of additional functionality and reduces server-side workload. For example, this allows us to keep the text to speech functionality on the client-side, as well as backup, message visualisation, analytics etc.

This approach maintains user privacy and allows for interesting functionality and separation of concerns by design.
\subsection{Push notifications}
It would be very helpful to include push notifications alerting users when they have new messages or other relevant information. The \href{https://developer.android.com/guide/topics/ui/notifiers/notifications}{Android API makes this fairly trivial to implement}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Analysis/Requirements}\label{analysis}
\section{Requirements}
\subsection{Minimum Viable Product}
\begin{itemize}
    \item Creation of accounts
    \item Logging in to accounts
    \item Pairing with other users (e.g. Friend Requests)
    \item Sending messages to paired users
    \item Push notifications for received messages on the relevant client
    \item Server-side db stores messages which have not been received yet and broadcasts them when user logs back in.
\end{itemize}
\subsection{Stretch Goals}
\begin{itemize}
    \item Text-to-speech (TTS) with Google WaveNet API or Azure TTS
    \item Group chats
    \item Ability to mute chats
    \item End-to-end encryption
    \item Chat logs saved on client side
    \item File and image sharing
\end{itemize}
\section{Technologies Used}
\subsection{Rust Server}
I've elected to use the Rust language\cite{matsakis2014rust} for the server, as it provides many advantages over other languages in terms of reliability, security and speed.

Rust is a statically typed language like Java or C, which aids with software maintainability by reducing type errors and makes the documentation process simpler\cite{hanenberg2014empirical}. 

Due to its extensive use of syntactic sugar \cite{pombrio2014resugaring} as well as type inference, Rust allows us to create programs which are slightly less verbose, more readable and and easier to structure than C, C++ or Java equivalents\cite{ardito2021evaluation}.

Additionally, it is not a garbage-collected language\cite{jones1996garbage} like Java, which allows for a significantly lower memory footprint as it allows for manual memory management. The major disadvantage of languages with direct memory management (e.g. C/C++) has traditionally been the lack of "memory safety"\cite{de2018meaning} - where direct memory allocation exposes the software to complex vulnerabilities such as buffer overflows and dangling pointers. Rust uses the twin concepts of "ownership" and "borrowing" \cite{levy2015ownership} to elegantly provide memory safety while also maintaining the low memory footprint and performance benefits of direct memory managed languages.


\subsection{Android Client}
Initially, the client application will be written for Android using Kotlin. Traditionally, Android apps have been written in Java\cite{murphy2008busy}, but since the endorsement of the Kotlin language as an official development language for Android in May 2017\cite{ardito2020effectiveness}, many developers have moved to using Kotlin.

The Kotlin programming language, like Java, runs on the Java Virtual Machine (JVM), which means that Java and Kotlin code can coexist within projects without issue. It provides a number of quality of life improvements for Java developers and reduces verbosity.

Development with Kotlin instead of Java is associated with higher quality applications\cite{mateus2019empirical}, as measured by presence (or lack) of "code smells". Code smells, defined by  Kent Beck and popularised by Martin Fowler\cite{beck1999bad}, refer to small signs or indications within the code of a program that there is a deeper problem lurking beneath.

Ardito et al found that in practice, Kotlin is a more concise language than Java and produces significantly fewer null pointer exceptions\cite{ardito2020effectiveness}.

It is likely that later on in the development stage SQLite3\cite{owens2010sqlite} will be used for a client-side db of chat history. SQLite is a highly performant embedded database which allows for local database storage without any networking required. Additionally, it has been built into Android since version 1.0 \cite{aditya2014android}   

\chapter{Timeline \& Final Product}
\section{Week by week}
\subsection{Week 0}
Initial meeting discussing potential project options.
\subsection{Week 2}
Final discussion and agreement on project proposal/outline.
\subsection{Week 4}
\begin{itemize}
    \item Build wireframes of android client using Balsamiq.
    \item Develop User Stories for application with MoSCoW prioritisation
    \item Begin populating Design chapter
\end{itemize}

\subsection{Weeks 6-8}
\begin{itemize}
    \item Begin writing and researching for literature review
    \item Start building Kotlin and Android development competency
    \item Work on communication between Rust server and Android app
    \item Make a decision about which E2EE algorithm to implement
    \item Design initial testing strategy
    \item Complete Design chapter
\end{itemize}
\subsection{Weeks 8-16}
\begin{itemize}
    \item Write Kotlin client application
    \item Write Rust server application
    \item Implement initial testing strategy
\end{itemize}
\subsection{Weeks 18-20}
\begin{itemize}
    \item Additional coding as required
    \item Write a plan for evaluation
    \item Final polish based on evaluation outcomes
\end{itemize}

\subsection{Weeks 22-24}
\begin{itemize}
    \item Focus on writing up final report
    \item Editing all previous work and proofreading
    \item Final polish on all areas
\end{itemize}

\section{Final Product}
The final output should be a Kotlin Android app which communicates with a Rust Server and includes all of the features of the Minimum Viable Product above and as many of the Stretch Goals that are achievable within the given timeframe.
%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Design and Implementation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Conclusion}\label{conclusion}

%\appendix % first appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{First appendix}

%\section{Section of first appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Second appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{acm}
\bibliography{mproj}
\end{document}
